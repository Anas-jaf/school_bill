#include "arduino_secrets.h"
#include "thingProperties.h"
#include <string>
#include <vector>
#include <sstream>
/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/82de6efb-d6d5-4832-8146-23875472e600 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  String currentMessage;
  String previousMessage;
  CloudSchedule timer;
  bool relay;
  bool status;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/


// الطابور الصباحي--8:16
// الحصة الاولى--8:31
// الحصة الثانية--9:16
// الحصة الثالثة--10:01
// وقت اللعب--10:47
// الحصة الرابعة--11:01
// الحصة الخامسة--11:46
// الحصة السادسة--12:31
// الحصة السابعة--13:16

// Bell pin configuration (simulate bell with LED or Buzzer)
const int bellPin = 0;  // Pin connected to the buzzer or bell

// Define target time (example: 4:15:00)
// const int targetHour = 4;
// const int targetMinute = 15;
// const int targetSecond = 0;

// Define time range and ring duration (in seconds)
// const int timeRange = 30;  // Time range for checking (in seconds)
const int ringDuration = 5;  // Ring duration (in seconds)

using namespace std;  // Use the standard namespace to avoid using std:: repeatedly

// // Function to extract times from the message
// vector<string> extractTimes(const string& doc) {
//     istringstream stream(doc);
//     string line;
//     vector<string> times;

//     // Split the string by new lines and extract times
//     while (getline(stream, line)) {
//         // Find the delimiter "--"
//         size_t delimiterPos = line.find("--");
//         if (delimiterPos != string::npos) {
//             // Extract the time part after "--"
//             string time = line.substr(delimiterPos + 2);
//             times.push_back(time);
//         }
//     }

//     // Return the vector of times
//     return times;
// }
vector<string> extractTimes(const string& doc) {
  istringstream stream(doc);
  string line;
  vector<string> times;

  // Split the string by new lines
  while (getline(stream, line)) {
    // Now split the line by double slashes "//"
    size_t delimiterPos = 0;
    while ((delimiterPos = line.find("//")) != string::npos) {
      // Extract the part before "//"
      string part = line.substr(0, delimiterPos);

      // Find the delimiter "--" within the part
      size_t timeDelimiterPos = part.find("--");
      if (timeDelimiterPos != string::npos) {
        // Extract the time after "--"
        string time = part.substr(timeDelimiterPos + 2);
        times.push_back(time);
      }

      // Remove the processed part (before "//") to handle the next part
      line.erase(0, delimiterPos + 2);
    }

    // After processing "//", handle the remaining part if any (still with "--")
    size_t timeDelimiterPos = line.find("--");
    if (timeDelimiterPos != string::npos) {
      string time = line.substr(timeDelimiterPos + 2);
      times.push_back(time);
    }
  }

  // Return the vector of times
  return times;
}

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  delay(1500);

  // Initialize bell pin as output
  pinMode(bellPin, OUTPUT);

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  // Set debug message level
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
}

void loop() {
  ArduinoCloud.update();
  if (ArduinoCloud.connected()) {
    unsigned long epochTime = ArduinoCloud.getLocalTime();

    // Extract hours, minutes, and seconds
    int daysSinceEpoch = epochTime / (24 * 3600);
    int dayOfWeek = (daysSinceEpoch + 4) % 7;  // Adjust to start week on Thursday
    int currentHour = (epochTime / 3600) % 24;
    int currentMinute = (epochTime / 60) % 60;
    int currentSecond = epochTime % 60;

    int minuteMargin = 2;  // Margin range in minutes
    int secondMargin = 5;  // Margin range in seconds
    int timeRange = minuteMargin * 60 + secondMargin;

    // Extract current month (approximation for debugging)
    int currentMonth = ((epochTime / 2629743) % 12) + 1;

    // Only proceed if the current message matches the previous message
    if (currentMessage == previousMessage) {

      if ((dayOfWeek != 5 && dayOfWeek != 6) || (currentMonth == 8 || currentMonth == 1)) {
        // Convert message to std::string for processing
        string previousMessageStr = String(previousMessage).c_str();
        vector<string> classes_period_time_array = extractTimes(previousMessageStr);

        for (const string& period_time_item : classes_period_time_array) {

          // Parse the time into hour, minute, and second
          int hour = 0, minute = 0, second = 0;

          if (sscanf(period_time_item.c_str(), "%d:%d:%d", &hour, &minute, &second) != 3) {
            // If the format is "HH:MM", set seconds to 0
            sscanf(period_time_item.c_str(), "%d:%d", &hour, &minute);
            second = 0;
          }

          // Compare extracted time with the current time (with margins)
          if (((hour == currentHour) || (hour == (currentHour + 1) % 24 && currentMinute + minuteMargin >= 60) || (hour == (currentHour - 1 + 24) % 24 && currentMinute - minuteMargin < 0)) && ((minute > currentMinute && minute - currentMinute <= minuteMargin) || (minute == currentMinute && second > currentSecond && second - currentSecond <= secondMargin) || (minute > currentMinute && secondMargin > 0 && second >= currentSecond))) {

            checkAndRingBell(currentHour, currentMinute, currentSecond, hour, minute, second, timeRange, ringDuration);
            break;  // Exit loop after ringing the bell
          }
        }
      }
    } else {
      previousMessage = currentMessage;  // Update the previous message
    }
  }
  delay(1000);  // Wait for 1 second before checking again
}

// Function to remove lines containing a specific word (default is "مواعيد")
string removeLinesWithWord(const string& text, const string& word = "مواعيد") {
  stringstream inputStream(text);
  stringstream outputStream;
  string line;

  // Process each line
  while (getline(inputStream, line)) {
    // Check if the line contains the word
    if (line.find(word) == string::npos) {
      // If the word is not found, add the line to the output
      outputStream << line << '\n';
    }
  }

  return outputStream.str();  // Return the filtered text
}

void checkAndRingBell(int currentHour, int currentMinute, int currentSecond, int targetHour, int targetMinute, int targetSecond, int timeRange, int ringDuration) {
  // Calculate time difference in seconds
  int currentTimeInSeconds = currentHour * 3600 + currentMinute * 60 + currentSecond;
  int targetTimeInSeconds = targetHour * 3600 + targetMinute * 60 + targetSecond;

  int timeDifference = abs(currentTimeInSeconds - targetTimeInSeconds);
  Serial.print("Time difference: ");
  Serial.println(timeDifference);

  // If time difference is within the allowed range, ring the bell
  if (timeDifference <= timeRange) {
    ringBell(ringDuration);
    delay((timeRange - ringDuration) * 1000);  // Wait for the remaining time after ringing
  }
  // else {
  //   Serial.println("No action required.");
  // }
}

void ringBell(int duration) {
  status = true;
  Serial.println("Ring the bell!");
  digitalWrite(bellPin, HIGH);  // Turn on the bell (LED/Buzzer)
  delay(duration * 1000);       // Wait for the duration (in milliseconds)
  digitalWrite(bellPin, LOW);   // Turn off the bell
  Serial.println("Stop ringing the bell!");
  status = false;
  relay = false;
}

void onMessageChange() {
  // Print the previous message before updating
  // Serial.print("Previous message: ");
  // Serial.println(previousMessage);
  // // Store the current message as the previous message for the next time
  // previousMessage = currentMessage;
  // // Update the current message with the new message
  // Serial.print("Current message: ");
  // Serial.println(currentMessage);
}

void onRelayChange() {
  if (relay) {
    // Serial.println(" on ");
    // digitalWrite(bellPin, HIGH);
    // status = true;
    ringBell(ringDuration);
  } else {
    // Serial.println(" off");
    // digitalWrite(bellPin, LOW);
    status = false;
  }
}

void onCurrentMessageChange() {
}
void onPreviousMessageChange() {
}
void onStatusChange() {
}
