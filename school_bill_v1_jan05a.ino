#include "arduino_secrets.h"

/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/82de6efb-d6d5-4832-8146-23875472e600 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  String currentMessage;
  String previousMessage;
  CloudSchedule timer;
  bool relay;
  bool status;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"
#include <string>
#include <vector>
#include <sstream> 
#include "thingProperties.h"

// Bell pin configuration (simulate bell with LED or Buzzer)
const int bellPin = 0;  // Pin connected to the buzzer or bell

// Define target time (example: 4:15:00)
const int targetHour = 4;
const int targetMinute = 15;
const int targetSecond = 0;

// Define time range and ring duration (in seconds)
const int timeRange = 30;  // Time range for checking (in seconds)
const int ringDuration = 5;  // Ring duration (in seconds)

using namespace std;  // Use the standard namespace to avoid using std:: repeatedly

// Function to extract times from the message
vector<string> extractTimes(const string& doc) {
    istringstream stream(doc);
    string line;
    vector<string> times;

    // Split the string by new lines and extract times
    while (getline(stream, line)) {
        // Find the delimiter "--"
        size_t delimiterPos = line.find("--");
        if (delimiterPos != string::npos) {
            // Extract the time part after "--"
            string time = line.substr(delimiterPos + 2);
            times.push_back(time);
        }
    }

    // Return the vector of times
    return times;
}

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  delay(1500); 

  // Initialize bell pin as output
  pinMode(bellPin, OUTPUT);
  
  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  // Set debug message level
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
}

void loop() {
  ArduinoCloud.update();
  // Your code here 
  if (ArduinoCloud.connected()) {
    timer = ArduinoCloud.getLocalTime();  // Get the local time from the cloud
    unsigned long epochTime = timer;

    // Add 3 hours to adjust for the +3 timezone offset
    // epochTime -= 3 * 3600;

    // Extract hours, minutes, and seconds
    int currentHour = (epochTime / 3600) % 24;  // Divide by 3600 to get hours, then modulo 24 to wrap around
    int currentMinute = (epochTime / 60) % 60;  // Divide by 60 to get minutes, then modulo 60 to keep it in range
    int currentSecond = epochTime % 60;        // The remainder when divided by 60 is the seconds

    Serial.println(epochTime);  // Print the original UTC time for debugging
    Serial.print("Adjusted Time: ");
    Serial.print(currentHour);
    Serial.print(":");
    Serial.print(currentMinute);
    Serial.print(":");
    Serial.println(currentSecond);

    // Convert currentMessage to time array and check for matches
    string previousMessageStr = String(previousMessage).c_str();  // Convert String to std::string
    vector<string> times = extractTimes(previousMessageStr);  // Pass as std::string
    
    for (const string& time : times) {
        // Parse the time into hour, minute, second
        int hour, minute, second = 0;
        if (sscanf(time.c_str(), "%d:%d:%d", &hour, &minute, &second) != 3) {
            // If the format is "HH:MM", set seconds to 0
            sscanf(time.c_str(), "%d:%d", &hour, &minute);
            second = 0;
        }

        // Compare extracted time with current time
        if (hour == currentHour && minute == currentMinute && second == currentSecond) {
            checkAndRingBell(currentHour, currentMinute, currentSecond, hour, minute, second, timeRange, ringDuration);
            break;  // Exit loop after finding a match and ringing the bell
        }
    }
  }
  delay(1000);  // Wait for 1 second before checking again
}



void checkAndRingBell(int currentHour, int currentMinute, int currentSecond, int targetHour, int targetMinute, int targetSecond, int timeRange, int ringDuration) {
  // Calculate time difference in seconds
  int currentTimeInSeconds = currentHour * 3600 + currentMinute * 60 + currentSecond;
  int targetTimeInSeconds = targetHour * 3600 + targetMinute * 60 + targetSecond;

  int timeDifference = abs(currentTimeInSeconds - targetTimeInSeconds);
  Serial.print("Time difference: ");
  Serial.println(timeDifference);

  // If time difference is within the allowed range, ring the bell
  if (timeDifference <= timeRange) {
    ringBell(ringDuration);
    delay((timeRange - ringDuration) * 1000);  // Wait for the remaining time after ringing
  } else {
    Serial.println("No action required.");
  }
}

void ringBell(int duration) {
  // Serial.println("Ring the bell!");
  digitalWrite(bellPin, HIGH);  // Turn on the bell (LED/Buzzer)
  delay(duration * 1000);       // Wait for the duration (in milliseconds)
  digitalWrite(bellPin, LOW);   // Turn off the bell
  // Serial.println("Stop ringing the bell!");
}

void onMessageChange() {
  // Print the previous message before updating
  Serial.print("Previous message: ");
  Serial.println(previousMessage);
  // Store the current message as the previous message for the next time
  previousMessage = currentMessage;
  // Update the current message with the new message
  Serial.print("Current message: ");
  Serial.println(currentMessage);
}

void onRelayChange()  {
  if (relay){
    digitalWrite(bellPin, HIGH);
    status = true;  
  }else{
    digitalWrite(bellPin, LOW);  
    status = false;
  }
}


/*
  Since CurrentMessage is READ_WRITE variable, onCurrentMessageChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onCurrentMessageChange()  {
  // Add your code here to act upon CurrentMessage change
}
/*
  Since PreviousMessage is READ_WRITE variable, onPreviousMessageChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onPreviousMessageChange()  {
  // Add your code here to act upon PreviousMessage change
}
/*
  Since Status is READ_WRITE variable, onStatusChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onStatusChange()  {
  // Add your code here to act upon Status change
}